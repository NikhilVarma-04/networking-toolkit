nikhilvarmadandu@192 ~ % cd ~/iptool
nano ip_network_tool.py










































nikhilvarmadandu@192 iptool % cd ~/iptool

nikhilvarmadandu@192 iptool % cd ~/ipcalc

cd: no such file or directory: /Users/nikhilvarmadandu/ipcalc
nikhilvarmadandu@192 iptool % ls

ip_network_tool.py
nikhilvarmadandu@192 iptool % rm ip_network_tool.py

nikhilvarmadandu@192 iptool % ls

nikhilvarmadandu@192 iptool % nano ip_network_tool.py

nikhilvarmadandu@192 iptool % python3.14 ip_network_tool.py

cd ~/iptool



nikhilvarmadandu@192 iptool % cd ~/iptool
nikhilvarmadandu@192 iptool % 
nikhilvarmadandu@192 iptool % 
nikhilvarmadandu@192 iptool % 
nikhilvarmadandu@192 iptool % cd ~/iptool

nikhilvarmadandu@192 iptool % nano ip_network_tool.py


  UW PICO 5.09                                                                                    File: ip_network_tool.py                                                                                      

#!/usr/bin/env python3
"""
IP Network Validator (IPv4)
--------------------------------
Features:
- Validate IPv4 address + subnet
- Determine IP class (A/B/C/D/E)
- Calculate:
    - Network address
    - Broadcast address
    - First usable host
    - Last usable host
    - Number of usable hosts
    - Subnet mask and prefix length
- Simple Tkinter GUI for classroom/demo use
"""

import os
os.environ["TK_SILENCE_DEPRECATION"] = "1"   # silence macOS Tk warning

import ipaddress
import tkinter as tk
from tkinter import ttk, messagebox


# ---------- Core networking logic ----------

def validate_ipv4(ip_str: str) -> bool:
    """Return True if ip_str is a valid IPv4 address (no mask), else False."""
    try:
        ipaddress.IPv4Address(ip_str)
        return True
    except Exception:
        return False


def get_ip_class(ip_str: str) -> str:
    """
    Class rules:
        Class A:   1   - 126
        Class B:   128 - 191
        Class C:   192 - 223
        Class D:   224 - 239 (Multicast)
        Class E:   240 - 254 (Experimental)
        127.x.x.x is Loopback/Reserved
    """
    try:
        first_octet = int(ip_str.split('.')[0])
    except Exception:
        return "Unknown"

    if 1 <= first_octet <= 126:
        return "Class A"
    if first_octet == 127:
        return "Loopback / Reserved"
    if 128 <= first_octet <= 191:
        return "Class B"
    if 192 <= first_octet <= 223:
        return "Class C"
    if 224 <= first_octet <= 239:
Search (to replace):                                                                                                                                                                                            
^G Get Help                       ^Y FirstLine                      ^R No Replace                     ^T LineNumber                     ^O End of Para                                                      
^C Cancel                         ^V LastLine                       ^^ Optns Menu                     ^W Start of Para                  ^U FullJustify                                                      
#!/usr/bin/env python3
"""
IP Network Validator (IPv4)
--------------------------------
Features:
- Validate IPv4 address + subnet
- Determine IP class (A/B/C/D/E)
- Calculate:
    - Network address
    - Broadcast address
    - First usable host
    - Last usable host
    - Number of usable hosts
    - Subnet mask and prefix length
- Simple Tkinter GUI for classroom/demo use
"""

import os
os.environ["TK_SILENCE_DEPRECATION"] = "1"   # silence macOS Tk warning

import ipaddress
import tkinter as tk
from tkinter import ttk, messagebox


# ---------- Core networking logic ----------

def validate_ipv4(ip_str: str) -> bool:
    """Return True if ip_str is a valid IPv4 address (no mask), else False."""
    try:
        ipaddress.IPv4Address(ip_str)
        return True
    except Exception:
        return False


def get_ip_class(ip_str: str) -> str:
    """
    Class rules:
        Class A:   1   - 126
        Class B:   128 - 191
        Class C:   192 - 223
        Class D:   224 - 239 (Multicast)
        Class E:   240 - 254 (Experimental)
        127.x.x.x is Loopback/Reserved
    """
    try:
        first_octet = int(ip_str.split('.')[0])
    except Exception:
        return "Unknown"

    if 1 <= first_octet <= 126:
        return "Class A"
    if first_octet == 127:
        return "Loopback / Reserved"
    if 128 <= first_octet <= 191:
        return "Class B"
    if 192 <= first_octet <= 223:
        return "Class C"
    if 224 <= first_octet <= 239:
        return "Class D (Multicast)"
    if 240 <= first_octet <= 254:
        return "Class E (Experimental)"
    return "Unknown"


def analyze_network(ip_str: str, mask_str: str | None) -> dict:
    """
    ip_str like "192.168.1.10"
    mask_str like "255.255.255.0" OR "24" OR "" (None)

    Returns dict of calculated values.
    Raises ValueError if invalid.
    """

    # Build an interface string that ipaddress understands.
    try:
        if "/" in ip_str and (mask_str is None or mask_str.strip() == ""):
            iface = ipaddress.IPv4Interface(ip_str.strip())
        else:
            if mask_str is None or mask_str.strip() == "":
                mask_part = "32"
            else:
                mask_part = mask_str.strip()
            iface = ipaddress.IPv4Interface(f"{ip_str.strip()}/{mask_part}")
    except Exception as e:
        raise ValueError(f"Invalid IP / Subnet: {e}")

    ip_addr = iface.ip
    net = iface.network

    network_address = net.network_address
    broadcast_address = net.broadcast_address

    if net.prefixlen < 31:
        first_usable = ipaddress.IPv4Address(int(network_address) + 1)
        last_usable = ipaddress.IPv4Address(int(broadcast_address) - 1)
        usable_hosts = max(net.num_addresses - 2, 0)
    else:
        first_usable = "N/A"
        last_usable = "N/A"
        usable_hosts = 0

    wildcard_mask = ipaddress.IPv4Address(
        (~int(net.netmask)) & 0xFFFFFFFF
    )

    info = {
        "Valid IP?": "Yes",
        "IP Address": str(ip_addr),
        "IP Class": get_ip_class(str(ip_addr)),
        "Subnet Mask": str(net.netmask),
        "Wildcard Mask": str(wildcard_mask),
        "CIDR Prefix": f"/{net.prefixlen}",
        "Network Address": str(network_address),
        "Broadcast Address": str(broadcast_address),
        "First Usable Host": str(first_usable),
        "Last Usable Host": str(last_usable),
        "Usable Host Count": usable_hosts,
        "Total Addresses in Subnet": net.num_addresses,
        "Private Address?": "Yes" if ip_addr.is_private else "No",
        "Globally Routable?": "Yes" if ip_addr.is_global else "No",
    }

    return info


# ---------- GUI behavior ----------

def run_validation(ip_entry: tk.Entry,
                   mask_entry: tk.Entry,
                   tree: ttk.Treeview,
                   status_label: ttk.Label):
    """
    Called when user clicks "Validate"
    """
    ip_in = ip_entry.get().strip()
    mask_in = mask_entry.get().strip()

    if not ip_in:
        messagebox.showerror("Error", "Please enter an IP address.")
        status_label.config(text="No IP entered", foreground="#b71c1c")
        return

    try:
        result = analyze_network(ip_in, mask_in if mask_in else None)
    except ValueError as err:
        for row in tree.get_children():
            tree.delete(row)
        messagebox.showerror("Invalid Input", str(err))
        status_label.config(
            text="Invalid IP / Subnet",
            foreground="#b71c1c"
        )
        return

    for row in tree.get_children():
        tree.delete(row)

    for key, value in result.items():
        tree.insert("", "end", values=(key, value))

    color_alternate_rows(tree)

    status_label.config(
        text="Validation successful",
        foreground="#1b5e20"
    )


def color_alternate_rows(tree: ttk.Treeview):
    """
    Give alternating rows soft colors.
    """
    tree.tag_configure("evenrow", background="#e3f2fd")   # pale blue
    tree.tag_configure("oddrow",  background="#fffde7")   # pale yellow

    for i, item_id in enumerate(tree.get_children()):
        tag = "evenrow" if i % 2 == 0 else "oddrow"
        tree.item(item_id, tags=(tag,))


def on_key_validate_ip(ip_entry: tk.Entry,
                       mask_entry: tk.Entry,
                       status_label: ttk.Label):
    """
    Live validation feedback (text only).
    Input boxes stay black text on white background.
    """
    ip_txt = ip_entry.get().strip()
    mask_txt = mask_entry.get().strip()

    ok = True
    if ip_txt:
        ok = ok and validate_ipv4(ip_txt.split("/")[0])
    else:
        ok = False

    if mask_txt:
        try:
            if mask_txt.isdigit():
                cidr_val = int(mask_txt)
                if not (0 <= cidr_val <= 32):
                    raise ValueError("Bad CIDR")
            else:
                ipaddress.IPv4Network(f"0.0.0.0/{mask_txt}")
        except Exception:
            ok = False

    if ok:
        status_label.config(
            text="Looks valid ðŸ‘",
            foreground="#1b5e20"
        )
    else:
        status_label.config(
            text="Invalid / incomplete âŒ",
            foreground="#b71c1c"
        )


# ---------- GUI layout ----------

def build_gui():
    root = tk.Tk()
    root.title("IP NETWORK VALIDATOR â€¢ CLASS â€¢ SUBNET RANGE")
    root.geometry("1000x640")
    root.configure(bg="#d9d9d9")  # light gray app background

    # Header bar
    header = tk.Label(
        root,
        text="IP NETWORK VALIDATOR â€¢ CLASS â€¢ SUBNET RANGE",
        bg="#1565c0",        # blue bar
        fg="white",          # white text
        font=("Segoe UI", 15, "bold"),
        pady=10
    )
    header.pack(fill="x")

    # Main container
    body = tk.Frame(root, bg="#d9d9d9")
    body.pack(fill="both", expand=True)

    # Input panel/card
    input_card = ttk.Frame(body, padding=15)
    input_card.place(relx=0.5, rely=0.15, anchor="n")

    # IPv4 Address label
    ttk.Label(
        input_card,
        text="IPv4 Address:",
        font=("Segoe UI", 11, "bold")
    ).grid(row=0, column=0, sticky="w", pady=5)

    # IPv4 Address entry (white bg, black text)
    ip_entry = tk.Entry(
        input_card,
        width=32,
        font=("Consolas", 11),
        bg="white",
        fg="black",
        insertbackground="black"
    )
    ip_entry.grid(row=0, column=1, padx=10, pady=5)

    # Subnet / Prefix label
    ttk.Label(
        input_card,
        text="Subnet Mask / CIDR Prefix (optional):",
        font=("Segoe UI", 11, "bold")
    ).grid(row=1, column=0, sticky="w", pady=5)

    # Subnet / Prefix entry (white bg, black text)
    mask_entry = tk.Entry(
        input_card,
        width=32,
        font=("Consolas", 11),
        bg="white",
        fg="black",
        insertbackground="black"
    )
    mask_entry.grid(row=1, column=1, padx=10, pady=5)

    # Status label under inputs
    status_label = ttk.Label(
        input_card,
        text="",
        font=("Segoe UI", 10, "italic")
    )
    status_label.grid(row=2, column=0, columnspan=2, sticky="w")

    # Bind live validation (text-only)
    ip_entry.bind(
        "<KeyRelease>",
        lambda e: on_key_validate_ip(ip_entry, mask_entry, status_label)
    )
    mask_entry.bind(
        "<KeyRelease>",
        lambda e: on_key_validate_ip(ip_entry, mask_entry, status_label)
    )

    # ttk style setup
    style = ttk.Style()
    style.theme_use("clam")

    # table header style: blue background, BLACK text (your request)
    style.configure(
        "Treeview.Heading",
        background="#1565c0",
        foreground="black",     # black header text
        font=("Segoe UI", 10, "bold")
    )
    style.configure(
        "Treeview",
        rowheight=26,
        font=("Consolas", 10)
    )
    style.map(
        "Treeview",
        background=[("selected", "#64b5f6")]
    )

    # "Validate" button with blue background and black text
    validate_btn = tk.Button(
        input_card,
        text="Validate",
        bg="#42a5f5",                 # blue background
        fg="black",                   # black text
        activebackground="#1e88e5",   # darker blue when pressed
        activeforeground="black",     # keep black text when pressed
        font=("Segoe UI", 12, "bold"),
        relief="raised",
        bd=4,
        width=20,
        command=lambda: run_validation(ip_entry, mask_entry, tree, status_label)
    )
    validate_btn.grid(row=3, column=0, columnspan=2, pady=12)

    # Results table card
    table_card = ttk.Frame(body, padding=10)
    table_card.place(relx=0.5, rely=0.38, anchor="n")

    columns = ("Property", "Value")
    tree = ttk.Treeview(
        table_card,
        columns=columns,
        show="headings",
        height=18
    )

    tree.heading("Property", text="Property")
    tree.heading("Value", text="Value")

    tree.column("Property", width=260, anchor="w")
    tree.column("Value", width=500, anchor="w")

    tree.grid(row=0, column=0, sticky="nsew")

    # Scrollbar
    scrollbar = ttk.Scrollbar(
        table_card,
        orient="vertical",
        command=tree.yview
    )
    tree.configure(yscroll=scrollbar.set)
    scrollbar.grid(row=0, column=1, sticky="ns")

    root.mainloop()


if __name__ == "__main__":
    build_gui()

